;;;; General utilities

(in-package :texonomy-util)

(deftype matrix (&optional type row col)
  "Matrix type."
  `(array ,type (,row ,col)))

(deftype square-matrix (&optional type dim)
  "Square matrix type."
  `(array ,type (,dim ,dim)))

(defun random-array (length start end)
  "Get an array of length LENGTH, numbers in array ranging from START to END."
  (declare (type fixnum length start end)
	   (optimize (speed 3) (safety 0)))
  (let ((out (make-array length :element-type 'fixnum))
	(rand (the fixnum (- end start))))
    (declare (type fixnum rand))
    (dotimes (i length)
      (setf (aref out i) (+ (the fixnum (random rand)) start)))
    out))

(defun random-matrix (row col start end)
  "Get a matrix of size ROW-by-COL, ranging from START to END."
  (declare (type fixnum row col start end))
  (let ((out (make-array `(,row ,col) :element-type 'fixnum))
	(rand (the fixnum (- end start))))
    (declare (type fixnum rand))
    (loop for i from 0 to (1- row) do
	 (loop for j from 0 to (1- col) do
	      (setf (aref out i j) (+ (the fixnum (random rand)) start))))
    out))

(defmacro with-gensyms ((&rest names) &body body)
  "Expand into code that binds all names to symbols generated by GENSYM."
  `(let ,(loop for n in names collect `(,n (gensym (format nil "~a-" ',n))))
     ,@body))

(defmacro doseq ((n seq) &rest body)
  "Sequence version of DOXXX macros."
  `(map nil #'(lambda (,n) ,@body) ,seq))

(defmacro dovec ((var vector) &body body)
  "Vector version of DOXXX macros."
  `(map nil #'(lambda (,var) ,@body) ,vector))

;;; TEST
(defun matrix-invert (matrix)
  "Get the inversion of a square matrix."
  (declare (type square-matrix matrix))
  (let* ((dim (array-dimension matrix 0))
	 (l (make-array dim :initial-element 0))
	 (m (make-array dim :initial-element 0))
	 (temp 0)
	 (det 1)
	 (out (make-array `(,dim ,dim) :initial-element 0)))
    (when (not (equal matrix out))
      (loop for i from 0 to (1- dim) do
	   (loop for j from 0 to (1- dim) do
		(setf (aref out i j) (aref matrix i j)))))
    (do ((k 0 (1+ k))
	 (maximum 0)
	 (1/max 0))
	((>= k dim))
      (setf (svref l k) k
	    (svref m k) k
	    maximum (aref out k k))
      (loop for i from k to (1- dim) do
	   (loop for j from k to (1- dim) do
		(when (> (abs (aref out i j)) (abs maximum))
		  (setf maximum (aref out i j)
			(svref l k) i
			(svref m k) j))))

      ;; Interchange rows with pivot.
      (if (> (svref l k) k)
	  (do ((j 0 (1+ j))
	       (i (svref l k)))
	      ((>= j dim))
	    (setf temp (- (aref out k j))
		  (aref out k j) (aref out i j)
		  (aref out i j) temp)))
      (if (> (svref m k) k)
	  (do ((i 0 (1+ i))
	       (j (svref m k)))
	      ((>= i dim))
	    (setf temp (- (aref out i k))
		  (aref out i k) (aref out i j)
		  (aref out i j) temp)))
      (if (equalp maximum 0)
	  (return-from matrix-invert 0))
      (setf 1/max (/ 1 maximum))
      (loop for i from 0 to (1- dim) do
	   (if (not (= i k))
	       (setf (aref out i k)
		     (* (aref out i k) (- 1/max)))))

      ;; Then reduce it.
      (loop for i from 0 to (1- dim) do
	   (when (not (= i k))
	     (setf temp (aref out i k))
	     (loop for j from 0 to (1- dim) do
		  (if (not (= j k))
		      (incf (aref out i j)
			    (* temp (aref out k j)))))))

      ;; Divide by pivot row.
      (loop for j from 0 to (1- dim) do
	   (if (not (= j k))
	       (setf (aref out k j)
		     (* (aref out k j) 1/max))))
      (setf det (* det maximum)
	    (aref out k k) 1/max))

    ;; And finally we are nearly done...
    (loop for n from (1- dim) downto 0 do
	 (if (> (svref l n) n)
	     (do ((j 0 (1+ j))
		  (i (svref l n)))
		 ((>= j dim))
	       (setf temp (aref out j n)
		     (aref out j n) (- (aref out j i))
		     (aref out j i) temp)))
	 (if (> (svref m n) n)
	     (do ((i 0 (1+ i))
		  (j (svref m n)))
		 ((>= i dim))
	       (setf temp (aref out n i)
		     (aref out n i) (- (aref out j i))
		     (aref out j i) temp))))
    ;; Return the inverted matrix and its determinant.
    (values out det)))
